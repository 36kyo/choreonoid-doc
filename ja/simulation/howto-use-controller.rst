
コントローラの導入
==================

.. sectionauthor:: 中岡 慎一郎 <s.nakaoka@aist.go.jp>

.. contents:: 目次
   :local:


コントローラの導入
------------------

シミュレーションにおいてロボットの制御を行うためには、シミュレーションプロジェクトにコントローラを導入する必要があります。導入の基本的な流れは以下のようになります。

1. 使用するコントローラアイテムの型を選択する
2. コントローラアイテムの型に適合したコントローラ本体を用意する
3. コントローラアイテムを生成し、Bodyアイテムの小アイテムとして配置する
4. コントローラアイテムにコントローラ本体をセットする

本節ではこれについて具体的な例を通して解説します。

シミュレーションプロジェクトの準備
----------------------------------

まず、 :doc:`simulation-project` で解説した手順に従って、コントローラ以外の要素が準備されたプロジェクトを作成しておくことにします。

コントローラの解説を行うため、今回はロボットモデルを用いることにします。 :ref:`bodymodel_samplemodels` の中に "SR1" というロボットモデルがありますので、これを使うことにしましょう。shareディレクトリの "model/SR1/SR1.yaml" を読み込んでください。

他に床のモデルとシミュレータアイテム、およびそれらをまとめるワールドアイテムを組み込んで、以下のようなプロジェクト構成にします。

.. image:: images/controller-project1.png

シーンビュー上ではロボットモデルが以下のように表示されているかと思います。

.. image:: images/controller-scene1.png

なお、SR1モデルは29個の関節を有する多リンクモデルであり、関節を動かすことで様々なポーズをとることが可能です。デフォルトでは図のような直立したポーズとなっていますが、他のポーズを初期状態としてシミュレーションを開始することも可能です。ポーズの編集方法については :doc:`../handling-models/index` の :doc:`../handling-models/pose-editing` や :doc:`../handling-models/legged-model` を参照してください。

:ref:`simulation_time_step` も忘れずに行っておきましょう。今回もとりあえず 1000 [fps] としておくことにします。

コントローラ無しの場合
----------------------

コントローラの効果を明確にするため、まずはコントローラが無いこの状態でシミュレーションを行ってみましょう。シミュレーションを開始すると、ロボットはどのようになるでしょうか？

.. image:: images/nocontroller-falldown.png

図のように、シミュレーション開始直後から床に倒れこんでいくことになります。

コントローラがないので、関節には何も指令がいっておらず、関節トルクを発生しない、力が入っていない状態となっています。一方で、デフォルトの設定で重力はかかるようになっているため、重力に従ってロボットの各リンクが床まで落下していくような動きになります。

このように、コントローラがなければ立っていることも出来ないということで、ロボットに関してはやはりコントローラがなければ始まりません。歩行させたり、作業させたりしようと思えば、それなりのコントローラが必要になるというわけです。

コントローラアイテム型の選択
----------------------------

Choreonoidでは、「コントローラアイテム」によってコントローラを導入します。コントローラアイテムは入出力の基盤を定義する抽象アイテム型であり、実際にはこれを継承したアイテム型を用います。また、一般的にはコントローラの本体はコントローラアイテムとは別に実装されるもので、そちらも用意しておく必要があります。

これは、コントローラ本体に関して、任意の実装形式をとれるようにするための仕組みです。実際のところ、ロボットのコントローラの形式には様々なものがあります。ロボットごとに独自のものもあれば、OpenRTMやROSといったミドルウェアの仕様に従って作成される場合もあります。コントローラアイテムはそれら各々の実装形式とChoreonoid上の仮想ロボットとの間の仲介役として機能します。実際に使用したいコントローラ本体の形式に対して、それに対応したコントローラアイテムを用いることで、コントローラ本体を導入するというわけです。

そのためには、使いたいコントローラの形式に対して、それに対応したコントローラアイテムが用意されている必要があります。現在Choreonoid本体に含まれているコントローラアイテムの型としては、以下のものがあります。

* **SimpleControllerアイテム**

 独自のコントローラ実装形式である"SimpleController"形式に対応したコントローラアイテムです。この形式は主にサンプルの実装を目的として、コントローラ実装のシンプルさを重視して設計されたものです。ただし汎用性はあまり重視されておらず、現実のロボットシステムに適用することを想定したものではありません。デフォルトで導入される "SimpleControllerプラグイン" によって利用可能となります。

* **BodyRTCアイテム**

 ロボット用ミドルウェアの規格である"OpenRTM"との連携を可能にするコントローラアイテムです。これを用いることで、OpenRTMのコンポーネントである"RTコンポーネント"を用いて仮想ロボットを制御することが可能となります。"OpenRTMプラグイン"を導入することで利用可能となります。

* **OpenHRPControllerアイテム**

 ロボットシミュレータ"OpenHRP"のコントローラ形式に対応したコントローラアイテムです。実際にはOpenHRPバージョン3.0の形式に対応した"OpenHRP3.0ControllerItem"と、バージョン3.1の形式に対応した"OpenHRP3.1ControllerItem"があります。それぞれのバージョン用のOpenHRPプラグインを導入することで使用可能になります。このコントローラアイテムはOpenHRPの資産に対応するために用意されたもので、今からこの形式のコントローラを用いる必要はありません。

既存のコントローラアイテムが対応していない形式のコントローラを用いるためには、そのためのコントローラアイテムを提供するChoreonoidプラグインを新たに開発する必要があります。

なお、近年利用の広まっているROSに関しては、これに対応するためのコントローラアイテムを現在開発中です。

.. note:: コントローラの導入方法としては、コントローラ本体をそのままコントローラアイテム継承型として実装するという方法もあります。この方法では仮想ロボットにアクセスするネイティブのAPIを直接利用することができるため、コントローラの自由度と効率を最大限に高めることが可能です。ただしそのコントローラはChoreonoidでしか使用できず、プラグインとして実装する手間もかかるため、この方法は一般的なものではありません。

コントローラ本体の用意
----------------------

選択したコントローラアイテム型に適合した形式のコントローラ本体を用意します。既存のコントローラを用いてもよいですし、必要であれば新たに開発します。

今回は例としてSimpleControllerアイテムを用いることにします。この場合、コントローラ本体としてSimpleController形式で実装されたものを用意します。SimpleController形式では、C++で"SimpleController"クラスを継承したクラスを定義して、いくつかの仮想関数をオーバーライドすることで制御コードを実装します。これをコンパイルして共有ライブラリ(.so)もしくはダイナミックリンクライブラリ(.DLL)のファイルとしたものが、コントローラの本体になります。


コントローラアイテムの生成
--------------------------

メインメニューの「ファイル」-「新規」から、使用するコントローラアイテム型を選択して生成します。生成したアイテムは、制御対象のBodyアイテムの小アイテムとして配置します。あらかじめBodyアイテムを選択してからコントローラアイテムを生成してもよいですし、生成後にこの配置になるようドラッグしてもOKです。この配置は、システムがコントローラアイテムの制御対象を特定するために必要な設定となっています。

今回の例では、「新規」メニューから「シンプルコントローラ」を選択してSimpleControllerアイテムを生成し、下図のようにSR1アイテムの下に配置します。

.. image:: images/controller-project2.png

.. note:: SimpleControllerアイテムを利用するためにはChoreonoidビルド時のCMakeオプションで"BUILD_SIMPLE_CONTROLLER_PLUGIN"がONになっている必要があります。（デフォルトではONになっています。）


コントローラ本体のセット
------------------------

コントローラアイテムにコントローラの本体をセットします。

SimpleControllerアイテムの場合、「コントローラDLL」というプロパティにコントローラ本体のファイル名を設定することで、これを行います。

なお、この指定においてディレクトリを省略しファイル名のみを記述すると、システム標準のディレクトリからファイルを検索します。標準ディレクトリは、 :doc:`../install/directories` で紹介した「プラグインディレクトリ」以下の "simplecontroller" というディレクトリになります。従って、コントローラ本体のファイルをここに格納しておけば、ファイル名だけでコントローラの指定ができます。また、".so"や".DLL"といった拡張子も省略可能です。拡張子を省略しておくことで、どのOSでも利用可能なプロジェクトとすることができます。

例として、SR1モデルを対象としたSimpleControllerのサンプルである "SR1MinimumController" をセットしてみましょう。これはロボットの現在の姿勢を維持するだけの非常に単純なコントローラです。このコントローラのファイルがシステム標準のディレクトリに格納されていることを確認した上で、SimpleControllerアイテムの「コントローラDLL」プロパティに、"SR1MinimumController" を設定してください。

.. note:: サンプルコントローラは、Choreonoidビルド時にCMakeオプションで"BUILD_SIMPLE_CONTROLLER_SAMPLES"がONになっていると生成されます。（デフォルトではONになっています。）

.. note:: コントローラ本体のセット方法は、コントローラアイテムによって特に異なってくる部分です。本節で述べたコントローラ導入の基本的な流れを踏まえた上で、実際に使用するコントローラアイテムのドキュメントに従って設定を行ってください。例えばBodyRTCアイテムの場合は、複数のRTコンポーネントを組み合わせてコントローラを構成することも可能ですが、コントローラのファイル名をひとつ指定するだけでこれを実現できるわけではなく、より複雑な設定が必要となってきます。

シミュレーションの実行
----------------------

以上の設定を行った上でシミュレーションを実行してください。実行や再生の操作は、コントローラが無い場合と比べて特に変わりありません。

上記の設定がうまくできていれば、今度はロボットが崩れ落ちることなく姿勢を維持できるはずです。"SR1MinimumController" に記述されたPD制御のコードにより、姿勢を維持するためのトルク指令が各関節に出力されているからです。

うまくいかない場合は、メッセージビューも確認してみてください。コントローラの設定や稼働に問題があると、シミュレーション開始時にその旨を知らせるメッセージが出力される場合があります。

なお、細かいことですが、コントローラがひとつだけ設定されたBodyモデルに対しては、シミュレーション結果はコントローラアイテムの小アイテムとして出力されるようになっています。これはアイテムツリーを見やすくするためで、コントローラが無い場合と比べて特に操作方法が変わるわけではありません。

コントローラのサンプルは他にも用意されています。 :ref:`basics_sample_project` を参考にして、他のサンプルも試してみてください。SR1モデルを対象としたサンプルとしては、歩行を行う "SR1Walk.cnoid" や、箱を持ち上げる "SR1Liftup.cnoid" といったプロジェクトがあり、コントローラによってロボットの動作が変わることを確認できます。







