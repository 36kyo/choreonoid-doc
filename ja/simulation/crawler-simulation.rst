
クローラのシミュレーション
==========================

.. sectionauthor:: 中岡 慎一郎 <s.nakaoka@aist.go.jp>

.. contents:: 目次
   :local:

.. highlight:: cpp


クローラとは
------------

「クローラ」は主に車両の移動のための機構です。別名で「無限軌道」「履帯」「キャタピラー」といった呼び方もあります。一般的に重機や戦車等に用いられており、ロボットの移動機構としても広く用いられています。他にベルトコンベアーもこの機構の一種であると言えます。

Choreonoidはこのクローラの簡易的なシミュレーションを行う機能を備えています。これは実際のクローラを精密に再現するものではないのですが、比較的平らな地面の上での移動などであれば、ある程度のシミュレーションを行うことができます。以下ではその利用方法について解説します。

クローラモデルの作成
--------------------

まずクローラを有するモデルを用意する必要があります。

クローラの部分は以下のようにして定義します。

* クローラ一式をひとつのリンクとする
* このリンクの関節タイプとして"crawler"を指定する
* 関節の可動軸パラメータにクローラの回転軸を指定する

クローラを含むモデルのサンプルとして、"Crawler"というモデルを用意しています。これはshareディレクトリの "model/misc/" 以下にある "crawler.wrl"というファイルで定義されており、以下のような外観をもっています。

.. image:: images/crawler-model.png

モデルの黒い部分がクローラに対応しており、左右にひとつずつ、計２つのクローラを有しています。

モデル全体は３つのリンクで構成されており、以下のような関節構造としています。

| + BODY (rootリンク）
|   + CRAWLER_TRACK_L (左クローラ）
|   + CRAWLER_TRACK_R (右クローラ)

BODYリンクはモデル中心部の緑色の部分に対応しています。

ここで、CRAWLER_TRACK_L はモデルファイルにおいて以下のように定義されています。 ::

 DEF CRAWLER_TRACK_L Joint {
   translation 0.0 0.15 0
   jointType "crawler"           
   jointAxis 0 1 0
   jointId 0
   children [
     DEF CRAWLER_TRACK_L_LINK Segment {
       ...
     }
   ]
 }

jointTypeフィールドに "crawler" を指定することで、このリンクがクローラであることを明示しています。

jointAxisは、クローラ内部の車輪を想定し、その回転軸に一致するようにします。ここでは "0 1 0"を指定し、Y軸と一致させています。

リンクの原点は、クローラ内部の点となるようにします。これについても、想定したクローラ内部の車輪に対して、その軸位置に一致させると分かりやすいかと思いますが、クローラ内部の点であればどこでも構いません。

サンプルモデルにおけるクローラの原点と回転軸は、モデルの前後方向にクローラが動くことを想定したモデリングとなっています。

対応シミュレータアイテム
------------------------

現在のところ、

* AISTSimulatorItem
* ODESimulatorItem
* BulletSimulatorItem

が簡易クローラシミュレーション機能に対応しています。

クローラを用いる際には、これらのシミュレータアイテムを用いてシミュレーションプロジェクトを作成するようにしてください。


簡易シミュレーションの概要
--------------------------

本機能によるクローラのシミュレーションは、あくまで簡易的なシミュレーションです。実際のクローラとは以下の点で異なります。

* クローラの表面が回らない
* クローラの表面が変形しない

クローラによる駆動力は、クローラ表面と環境との間に力を直接付与することで実現しています。この力は、接触点における相対速度が目標値となるような拘束条件から算出しています。これは実際のクローラの駆動メカニズムとは異なりますので注意が必要です。

また、実物のクローラではその表面が環境に合わせて変形することによって安定性や走破性を高めているわけですが、簡易シミュレーションではそのような変形も生じません。結果として、凹凸のある地形での安定性や走破性は実物よりもずっと劣るものとなってしまいます。

.. note:: 変形については、クローラのリンクを細かく分けて、それぞれにサスペンションのような関節を付与し、そこにバネダンパ力を与えることである程度は実現できるかもしれません。ただしモデルが複雑になる分シミュレーション速度は遅くなってしまいます。

接触点に付与する力の向きは、クローラの回転軸と接触法線の外積（クロス積）の向きとしています。サンプルモデルのクローラが以下のように環境と接しているとき、これらのベクトルは以下のようになっています。

.. image:: images/crawler-vectors.png

クローラの回転軸は図の正面側（Y軸方向）に向いたベクトルとなっています。環境との接触点における接触法線を青矢印とすると、回転軸と接触点の外積をとったベクトルが赤矢印で、正の指令値を入力した際にはこの方向への駆動力が発生します。この結果、クローラ全体は図の左側(X軸方向）に進んで行き、階段も乗り越えていくことになります。


指令値の与え方
--------------

クローラの簡易シミュレーションにおいて、クローラへの指令値は、クローラの駆動速度（接触点で実現すべき相対速度）の大きさとして与えます。これを行うためのインタフェースは、現在のところ関節トルクのインタフェースと共有するかたちをとっています。つまり、インタフェース上は関節トルクに値を入力すると、実際にはこれがクローラへの速度指令値として扱われることになります。

例えば、サンプルモデルのクローラをSimpleControllerを用いて駆動させる場合、制御ループで以下のような処理を行えばOKです。 ::

 ioBody()->joint("CRAWLER_TRACK_L")->u() = 1.0;
 ioBody()->joint("CRAWLER_TRACK_R")->u() = 1.0;

このようにすると、左右のクローラに同じ駆動力が与えられて、モデル全体が1.0[m/s]の速度で前方に進むことになります。

また、以下のように左右に異なる指令値を与えることで、モデルを旋回させることができます。 ::

 ioBody()->joint("CRAWLER_TRACK_L")->u() =  1.0;
 ioBody()->joint("CRAWLER_TRACK_R")->u() = -1.0;

この場合、モデルが右に回転します。


シミュレーションサンプル
------------------------

サンプルクローラモデルを動かすサンプルとして、"SampleCrawler.cnoid" というプロジェクトがあります。このプロジェクトでシミュレーションを実行すると、クローラモデルが図のように床の段差を乗り越えながら移動します。

.. image:: images/SampleCrawlerProject.png

ここで使われているコントローラはSimpleController形式で実装されています。ソースファイルは "src/sample/SimpleController/SampleCrawlerController.cpp" になりますので、参考にしてください。

また、"SampleCrawlerJoystick.cnoid"では、ジョイスティックによってクローラモデルを操作することができます。ジョイスティックを接続していない場合、以下の「仮想ジョイスティックビュー」を用いることでジョイスティックと同様の操作が可能です。

.. image:: images/VirtualJoystickView.png

シミュレーションを開始したらこのビューの内部をクリックしてキーボードフォーカスを入れます。ジョイスティック（ゲームパッド）の左下のアナログスティックの上下左右がキーボードの"E"、"D"、"S"、"F"に割り当てられており、これらのキーを押すことでクローラモデルを操作できます。

このコントローラのソースは "src/sample/SimpleController/SampleCrawlerJoystickController.cpp" になります。
