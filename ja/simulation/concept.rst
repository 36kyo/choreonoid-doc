
基本概念
========

.. contents::
   :local:
   :depth: 1


シミュレーション機能
--------------------

Choreonoidはシミュレーション機能を備えており、ロボットシミュレータとして利用することが可能です。ロボットや環境物体がどのように動くかを計算によってシミュレートし、その結果を3DCGによるアニメーションで表示したり、データとして出力します。この機能を用いることで、実際のロボットを動かすことなく、ハードウェア設計やソフトウェアに関する検証を行ったり、操作や運用の練習を行うといったことが可能となります。

シミュレーションの対象となるのは、 :doc:`../handling-models/index` で紹介したBodyモデルです。BodyモデルをBodyアイテムとして読み込んでおき、さらにそれらをWorldアイテムでひとつの仮想世界に所属させることで、この仮想世界を対象としたシミュレーションが可能となります。


物理計算エンジン
----------------

シミュレータのコアとなる部分は、物体が物理的にどのように動くかを計算する部分で、これを「物理計算エンジン」と呼びます。物理計算のアルゴリズムは様々なものが考案されており、その実装も様々なものがあり得るため、物理計算エンジンについてもこれまで様々なものが開発されています。シミュレーション可能なモデルや物理現象はエンジン次第ですし、シミュレーションの精度、安定性、計算速度といった特性もエンジンによって異なってきますので、シミュレーションの対象や目的に応じてエンジンを使い分けることが重要です。この観点から、Choreonoidは様々な物理計算エンジンが使えるように設計されています。


シミュレータアイテム
--------------------

Choreonoidにおいて物理計算エンジンは「シミュレータアイテム」というプロジェクトアイテムとして表現されます。
利用可能な物理計算エンジンごとに、対応するシミュレータアイテム（SimulatorItemのサブクラス）が用意されることになります。
具体的には、以下のようなシミュレータアイテムが利用可能となっています。

* **AISTSimulatorItem**

 Choreonoid標準のシミュレータアイテムで、独自の物理計算エンジンによりシミュレーションを行います。

* **ODESimulatorItem**, **BulletSimulatorItem**, **PhysXSimulatorItem**

 それぞれ、ライブラリとして外部から利用可能な物理計算エンジンである `Open Dynamics Engine (ODE) <http://www.ode.org/>`_ , `Bullet Physics Library <http://bulletphysics.org>`_, `PhysX <https://developer.nvidia.com/gameworks-physx-overview>`_ を利用するシミュレータアイテムです。対応するライブラリをインストールして ODEPlugin, BulletPlugin, もしくはPhysXPluginをビルドすることにより利用可能となります。

.. note:: 物理計算においてはシミュレーション対象の物体間に生じる干渉の検出も必要であり、通常はこれを行う干渉検出器も物理計算エンジンに含まれます。一方で、 :doc:`../handling-models/index` の :doc:`../handling-models/collision-detection` で解説したように、Choreonoidの基本機能として用意された干渉検出機能も存在し、こちらについても様々な干渉検出器が利用可能となっています (:ref:`handling-models_switch-collision-detector`)。シミュレータアイテムによっては基本機能として用意された干渉検出機能から、任意の干渉検出器を利用可能となっているものもあります。

シミュレータアイテムはプラグインによって追加することができます。物理計算エンジンがソフトウェアライブラリとして外部から利用可能となっていれば、それを利用するシミュレータアイテムは比較的簡単に実装することができます。実装方法については :doc:`../plugin-development/index` の :doc:`../plugin-development/ode-plugin` を参考にしてください。

サブシミュレータアイテム
------------------------

物理計算は基本的にシミュレータアイテムによって行われますが、これを補足して様々なシミュレーション機能を実現するために「サブシミュレータアイテム」も利用可能となっています。

例えば、ロボットに搭載されたカメラや距離センサの機能をシミュレートして、カメラ画像や距離画像をシミュレーション中にも取得できるようにしたい場合があります。この機能を追加するサブシミュレータアイテムとして"GLVisionSimulatorItem"が用意されています。このサブシミュレータでは、3DCG表示と同様の描画処理をカメラや距離センサの視点で内部的に行うことにより、センサの出力をシミュレートします。これを「物理計算エンジン」との対比で言えば、「視覚情報計算エンジン」とでも言うことができるでしょう。この機能は物理計算のアルゴリズムには依存しませんので、どのシミュレータアイテムとも組み合わせて利用することが可能です。

サブシミュレータアイテムでは、仮想世界の状況を監視して、それに応じた出力を行ったり、仮想世界に手を加えるといった枠組みで、他にも様々な機能を実現できます。独自のシミュレーション機能を実装したサブシミュレータアイテムを、プラグインによって追加することも可能です。

コントローラ
------------

ロボットを動かすためにはそれを制御するプログラムが必要で、これを「コントローラ」と呼びます。シミュレーションにおいても、ロボットを動かすためにはコントローラが必要です。一般的には、ロボット実機を動かすためのコントローラと、シミュレーションで用いるコントローラについて、共通のものを使います。このようにすることで、コントローラの開発や検証をシミュレータ上で効率的に行おうというわけです。また、こうしておけば、開発したロボットシステムのユーザがその操作や運用をシミュレータ上で練習することも可能となります。

いずれにしても、ロボットを動かすためにはコントローラが必要であり、これもシミュレーションを構成するの主要な要素のひとつとなります。


ロボットとコントローラ間の入出力
--------------------------------

コントローラがロボットを制御するためにまず必要なことは、ロボットとの間で各種データの入出力を行うことです。すなわち、コントローラはまずロボットに搭載された各種センサからの入力でロボットや環境の状態を取得し、これに基づく制御計算を行った後、決定した指令値をロボットのアクチュエータ等に出力するわけです。

実際に入出力の対象となるものを、以下に示します。


関節角度・トルク
~~~~~~~~~~~~~~~~

ロボットの現在の関節角度を取得し、関節を駆動するための指令値をアクチュエータに出力することは、ロボットの制御において最も基本的な入出力です。
.. 実際のロボットでこれは通常関節に装着されたエンコーダとアクチュエータを対象として行われることになりますが、シミュレーションにおいては関節角度と関節トルクの値をそのままやりとりすることになります。

関節角度については、実際のロボットでは通常エンコーダを通して取得することになり、精度もこれに依存することになりますが、シミュレーションにおいては基本的には現在のモデルの状態値をそのまま入力することになり、精度が悪くなることはありません。逆にエンコーダの特性を正確に反映したい場合には、そのためのフィルタ的な処理が必要になります。

指令値については、実際のロボットのアクチュエータでは関節角度や電流値等、様々な形態が有りますが、シミュレーションにおいては最終的にトルク値として出力する必要があります。

.. note:: シミュレータアイテムによっては、指令値について目標角度（実際にはそれを実現する速度や加速度）で指定する「ハイゲインモード」が利用できるものもあります。詳しくは :doc:`high-gain-simulation` を参照ください。

デバイス
~~~~~~~~

ロボットの入出力の対象となるものは、関節エンコーダ／アクチュエータ以外にもあります。それらはChoreonoidのBodyモデルでは「デバイス」という形式で表現されます。対象となるデバイスをBodyモデルから取得し、デバイスのインタフェースを通すことで、対象デバイスへの入出力を行うことができます。デバイスは大きく「センサデバイス」と「アクティブデバイス」の２つに分けられます。

センサデバイス
''''''''''''''
センサに対応するデバイスです。これを通してロボットや環境の状態を取得します。

センサデバイスの例として、

* 力センサ、加速度センサ、角速度センサ（ジャイロ）といった力学的なセンサ
* カメラ、レーザーレンジファインダといった光学的なセンサ

があります。

アクティブデバイス
'''''''''''''''''''

外界に働きかけるデバイスに対応します。このデバイスの例として、ライト（光源）があります。


コントローラアイテム
--------------------

コントローラは、Choreonoid上では「コントローラアイテム」として表現されます。

コントローラアイテムは、入出力の基本となる部分を定義したアイテムで、実際のコントローラはこのアイテムを継承したアイテムとして実装します。

また、ある特定の形式で入出力を行うためのコントローラアイテムも定義可能です。この場合、実際の制御プログラムはアイテムとは別のモジュールとして実装し、それをコントローラアイテムに紐付けるかたちで利用します。こうすることで、コントローラをシンプルに実装できたり、既存のロボット用ミドルウェアを用いることができるようになり、コントローラを実機とシミュレーションで共通化することも容易になるため、通常はこの方式でコントローラを接続します。

例えば、ロボット用ミドルウェアであるOpenRTMでは、ロボットや制御プログラムが「RTコンポーネント」として表現され、コンポーネントのポートを介してデータの入出力を行います。この形式に対応させるためのコントローラアイテムである「BodyRTCアイテム」がOpenRTMプラグインによって提供されています。BodyRTCアイテムによって、ロボットの関節やデバイスに対応する入出力ポートを備えたRTコンポーネントが生成されます。これと制御用のRTコンポーネントを接続することにより、RTコンポーネントを用いた制御がシミュレーションでも利用可能となります。これについては :doc:`../openrtm/index` で詳細を解説します。
