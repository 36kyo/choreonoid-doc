
基本概念
========

.. contents::
   :local:
   :depth: 1


シミュレーション機能
--------------------

Choreonoidはシミュレーション機能を備えており、ロボットシミュレータとして利用することが可能です。ロボットや環境物体がどのように動くかを計算によってシミュレートし、その結果を3DCGによるアニメーションで表示したり、データとして出力します。この機能を用いることで、実際のロボットを動かすことなく、ハードウェア設計やソフトウェアに関する検証を行ったり、操作や運用の練習を行うといったことが可能となります。

シミュレーションの対象となるのは、 :doc:`../handling-models/index` で紹介したBodyモデルです。BodyモデルをBodyアイテムとして読み込んでおき、さらにそれらをWorldアイテムでひとつの仮想世界に所属させることで、この仮想世界を対象としたシミュレーションが可能となります。


物理計算エンジン
----------------

シミュレータのコアとなる部分は、物体が物理的にどのように動くかを計算する部分で、これを「物理計算エンジン」と呼びます。物理計算のアルゴリズムは様々なものが考案されており、その実装も様々なものがあり得るため、物理計算エンジンについてもこれまで様々なものが開発されています。シミュレーション可能なモデルや物理現象はエンジン次第ですし、シミュレーションの精度、安定性、計算速度といった特性もエンジンによって異なってきますので、シミュレーションの対象や目的に応じてエンジンを使い分けることが重要です。この観点から、Choreonoidは様々な物理計算エンジンが使えるように設計されています。


シミュレータアイテム
--------------------

Choreonoidにおいて物理計算エンジンは「シミュレータアイテム」というプロジェクトアイテムとして表現されます。
利用可能な物理計算エンジンごとに、対応するシミュレータアイテム（SimulatorItemのサブクラス）が用意されることになります。
具体的には、以下のようなシミュレータアイテムが利用可能となっています。

* **AISTSimulatorItem**

 Choreonoid標準のシミュレータアイテムで、独自の物理計算エンジンによりシミュレーションを行います。

* **ODESimulatorItem**, **BulletSimulatorItem**, **PhysXSimulatorItem**

 それぞれ、ライブラリとして外部から利用可能な物理計算エンジンである `Open Dynamics Engine (ODE) <http://www.ode.org/>`_ , `Bullet Physics Library <http://bulletphysics.org>`_, `PhysX <https://developer.nvidia.com/gameworks-physx-overview>`_ を利用するシミュレータアイテムです。対応するライブラリをインストールして ODEPlugin, BulletPlugin, もしくはPhysXPluginをビルドすることにより利用可能となります。

.. note:: 物理計算においてはシミュレーション対象の物体間に生じる干渉の検出も必要であり、通常はこれを行う干渉検出器も物理計算エンジンに含まれます。一方で、 :doc:`../handling-models/index` の :doc:`../handling-models/collision-detection` で解説したように、Choreonoidの基本機能として用意された干渉検出機能も存在し、こちらについても様々な干渉検出器が利用可能となっています (:ref:`handling-models_switch-collision-detector`)。シミュレータアイテムによっては基本機能として用意された干渉検出機能から、任意の干渉検出器を利用可能となっているものもあります。

シミュレータアイテムはプラグインによって追加することができます。物理計算エンジンがソフトウェアライブラリとして外部から利用可能となっていれば、それを利用するシミュレータアイテムは比較的簡単に実装することができます。実装方法については :doc:`../plugin-development/index` の :doc:`../plugin-development/ode-plugin` を参考にしてください。

サブシミュレータアイテム
------------------------

物理計算は基本的にシミュレータアイテムによって行われますが、これを補足して様々なシミュレーション機能を実現するために「サブシミュレータアイテム」も利用可能となっています。

例えば、ロボットに搭載されたカメラや距離センサの機能をシミュレートして、カメラ画像や距離画像をシミュレーション中にも取得できるようにしたい場合があります。この機能を追加するサブシミュレータアイテムとして"GLVisionSimulatorItem"が用意されています。このサブシミュレータでは、3DCG表示と同様の描画処理をカメラや距離センサの視点で内部的に行うことにより、センサの出力をシミュレートします。これを「物理計算エンジン」との対比で言えば、「視覚情報計算エンジン」とでも言うことができるでしょう。この機能は物理計算のアルゴリズムには依存しませんので、どのシミュレータアイテムとも組み合わせて利用することが可能です。

サブシミュレータアイテムでは、仮想世界の状況を監視して、それに応じた出力を行ったり、仮想世界に手を加えるといった枠組みで、他にも様々な機能を実現できます。独自のシミュレーション機能を実装したサブシミュレータアイテムを、プラグインによって追加することも可能です。

コントローラ
------------

ロボットを動かすためにはそれを制御するプログラムが必要で、これを「コントローラ」と呼びます。シミュレーションにおいても、ロボットを動かすためにはコントローラが必要です。一般的には、ロボット実機を動かすためのコントローラと、シミュレーションで用いるコントローラについて、共通のものを使います。このようにすることで、コントローラの開発や検証をシミュレータ上で効率的に行おうというわけです。また、こうしておけば、開発したロボットシステムのユーザがその操作や運用をシミュレータ上で練習することも可能となります。

いずれにしても、ロボットを動かすためにはコントローラが必要なわけで、これもシミュレーションを構成するの主要な要素のひとつとなります。


ロボットとコントローラ間の入出力
--------------------------------------

関節角度・トルク
~~~~~~~~~~~~~~~~

デバイス
~~~~~~~~

センサデバイス
''''''''''''''

アクティブデバイス
'''''''''''''''''''



コントローラアイテム
--------------------


