OpenRTMによる遠隔操作サンプル
=============================

:doc:`simulation-samples` では、シミュレータ上で直接ロボットの操作もできるサンプルを紹介しました。しかし、実際の競技ではロボットの操作はシミュレーション用PCとは異なるPC上で行い、遠隔操作とする必要があります。ロボットの操作を遠隔操作可する手段として、ここではOpenRTMを用いたサンプルを紹介します。

.. contents::
   :local:

OpenRTMの準備
-------------

OpenRTMによる遠隔操作を行うための準備として、まず :ref:`wrs2018_install_openrtm` をしておく必要があります。Choreonoidのビルドにおいても、

 * ENABLE_CORBA
 * BUILD_CORBA_PLUGIN
 * BUILD_OPENRTM_PLUGIN
 * BUILD_OPENRTM_SAMPLES

を有効にして、OpenRTM関連の機能やサンプルをビルドするようにしてください。

omniORBの最大メッセージサイズの設定
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

他に必要な設定としては、omniORBの最大メッセージサイズを増やしておいた方がよいです。omniORBというのはOpenRTM-aistの実装で使用されているCORBAライブラリで、OpenRTMのインストールの際にはこれもインストールされます。この設定ファイル /etc/omniORB.cfg がありますので、ルート権限でこのファイルを編集します。設定ファイルの中に ::

 giopMaxMsgSize = 2097152   # 2 MBytes.

という記述があるかと思うのですが、これが最大メッセージサイズを表しています。

デフォルトでは2MBとなっているのですが、この場合、例えば画像データやポイントクラウドデータの通信などで一度に2MB以上のサイズのデータを送信しようとすると、うまく送信できないことになってしまいます。2MBという値は小さいので、この値を増やしておきましょう。例えばこれを20MBにする場合、 ::

 giopMaxMsgSize = 20971520

に修正します。

omniNamesのキャッシュのクリア
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OpenRTMがベースとして利用しているCORBAという通信規格では、「ネームサーバ」というものを使用します。これはCORBAで扱う「CORBAオブジェクト」のネットワーク上でのアドレスを登録するためのものです。omniORBをインストールすると、omniNamesというネームサーバもインストールされ、デフォルトで使用されるようになっています。

このomniNamesについて、登録されていたオブジェクトの情報をOSの再起動時に復帰するという「キャッシュ」の機能があります。このキャッシュによって、存在しないオブジェクトの情報が蓄積してしまい、これがシステムの挙動に影響を与えることがあります。CORBAオブジェクトのアドレスはIPアドレスも含むものなので、ネットワーク上のPC構成が変わったり、ネットワーク自体が変わったりすると、容易にこの問題が発生します。

この問題を避けるため、ネットワーク構成が変わる度にキャッシュをクリアした方がよいです。キャッシュのクリアはChoreonoidに含まれる "reset-omninames.sh" というスクリプトで行うことができます。なお、このスクリプトの実行には管理者権限が必要です。実行時にはそのためのパスワードを求められた場合は、パスワードを入力して実行してください。

OpenRTM関連の動作がうまくいかない場合、キャッシュが悪さをしていることもありますので、その場合は一度システムを全て止めてから、このスクリプトを実行するとよいかと思います。

参考: :doc:`../openrtm/index` / :doc:`../openrtm/reset-omniname`

遠隔操作サンプルの実行
----------------------

OpenRTMによる遠隔操作を行う場合、まずシミュレーションを行うChoreonoid上にRTCを導入し、ロボットの操作に必要な入出力をRTコンポーネント経由でできるようにします。

そのように設定したサンプルを、 :doc:`simulation-samples` で紹介したサンプルに "-RTM" のサフィックスをつけた名前で提供しています。

今のところ、以下のプロジェクトを用意しています。

* T1-AizuSpiderSA-RTM.py
* T1-AizuSpiderSS-RTM.py

:doc:`simulation-samples` で説明したのと同じ要領で、上記のどちらかのプロジェクトを読み込んでください。

次に、遠隔操作側を用意します。OpenRTMによる遠隔操作サンプルでは、遠隔操作端末にもChoreonoidを使うようにしています。

遠隔操作端末となるChoreonoidを起動しましょう。そのためのプロジェクトファイルは、 sample/OpenRTM/OpenRTM-AizuSpider-Terminal.cnoid になります。シミュレーション用のChoreonoidは起動したまま、2つ目のChoreonoidとして起動するようにします。例えば、ソースディレクトリから ::

 bin/choreonoid sample/OpenRTM/OpenRTM-AizuSpider-Terminal.cnoid

と入力します。

遠隔操作端末のChoreonoidは、以下のような画面になるかと思います。

.. image:: images/openrtm-terminal1.png

画面中央にあるのは、「RTCダイアグラムビュー」と呼ばれるものです。これはOpenRTMの標準ツールである "RT System Editor" と同様の機能を提供するものです。

このダイアグラムの中で、"AizuSpider-JoystickInput" はシミュレーション用のChoreonoidで設定・生成されているRTCです。これはジョイスティックの入力ポートを持っており、ジョイスティックの状態をロボットの制御プログラムに伝えるためのものです。

また、"AizuSpider-VisionSensorIoRTC" というのは、やはりシミュレーション用のChoreonoidで設定・生成されているRTCで、視覚センサのデータを出力するポートを備えています。ロボットが搭載している視覚センサの数だけ出力ポートがあります。ポートの名前はセンサの名前に対応しています。

一方で、"JoystickRTC0" は、遠隔操作端末のChoreonoid（つまりこの画面のChoreonoid）で生成されているRTCです。これは名前のとおりジョイスティックに対応するもので、ジョイスティックの状態を出力するRTCとなっています。この出力ポートを "AizuSpider-JoystickInput" の入力ポートに接続することで、ジョイスティックの状態をロボットに伝えられるようになります。

"CameraImage" は、カメラ画像を表示するビューに対応するRTCです。これは画面の右側で "CameraImage" という名前がつけられたビューになります。これも、ポート接続を行うことにより、ロボットのカメラ画像を端末側で表示することが可能となります。

この状態では、まだシミュレーションが開始していない（＝ロボットが動作していない）ため、ロボット側の "AizuSpider-JoystickInput" と "AizuSpider-VisionSensorIoRTC" はアクティベートされておらず、青色で表示されています。一方、端末側の "JoystickRTC0" と "CameraImage" は既に使える状態で、RTCもアクティベート状態となっており、緑色で表示されています。

ではシミュレーションを開始し、遠隔操作を行うことにしましょう。「シミュレーション側のChoreonoid」で、シミュレーション開始の操作を行ってください。（端末側のChoreonoidで行っても何も起きませんのでご注意ください。）

すると端末側のChoreonoidは以下のような表示になったかと思います。

.. image:: images/openrtm-terminal2.png

シミュレーションが開始したことで、ロボット側のRTCがアクティブ状態（緑色）となりました。また、CameraImageビューに、ロボットのカメラの画像が表示されているかと思います。ここでゲームパッドを操作すると、ロボットの操作を行うことができます。

PC2台を用いた遠隔通信
---------------------

上で試してもらったのは、シミュレーション（ロボット）側も操作側も同じPC上で動かすものでした。この場合でも両者の間でOpenRTMによる通信は行っておりますが、本来は :ref:`wrs2018_overview_operation` で述べたように、シミュレーション側と操作側を別々のPCとし、それらの間で遠隔通信を行わなければなりません。

これを実現するため、まずChoreonoidが動作するPCを2台用意してください。片方をシミュレーション用PCとし、もう片方を操作端末用PCとします。なお、シミュレーションはスペックの高いPCで行うことが望ましいですが、端末側は（今回のサンプルに関しては）高いスペックは必要ないため、2台のPCでスペックに差がある場合は、スペックの高い方のPCをシミュレーション用PCに割り当てるようにします。

あとは上述の操作をシミュレーション用PCと端末用PCのそれぞれで分けて行えばよいのですが、その前にひとつ設定すべきことがあります。2台のPCが通信するためには、ネットワーク上のどのPCと通信するのかが分かっていなければなりません。






